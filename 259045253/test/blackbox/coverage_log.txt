============================= test session starts ==============================
platform darwin -- Python 3.12.3, pytest-8.4.2, pluggy-1.6.0
rootdir: /Users/syedfasiuddin/Developer/uni-leic/smqa-coursework
configfile: pyproject.toml
collected 1785 items

259045253/test/blackbox/category_partition/chars_and_strings_test.py ... [  0%]
....                                                                     [  0%]
259045253/test/blackbox/category_partition/cli_arg_test.py .....         [  0%]
259045253/test/blackbox/category_partition/continue_stmt_test.py ...     [  0%]
259045253/test/blackbox/category_partition/for_loop_test.py ..           [  0%]
259045253/test/blackbox/category_partition/if_stmt_test.py .....         [  1%]
259045253/test/blackbox/category_partition/null_type_test.py ..          [  1%]
259045253/test/blackbox/category_partition/pass_filename_test.py ....    [  1%]
259045253/test/blackbox/category_partition/print_function_test.py ...... [  1%]
                                                                         [  1%]
259045253/test/blackbox/random_testing/test_src_evaluator.py ........... [  2%]
........................................................................ [  6%]
........................................................................ [ 10%]
........................................................................ [ 14%]
........................................................................ [ 18%]
........................................................................ [ 22%]
........................................................................ [ 26%]
........................................................................ [ 30%]
........................................................................ [ 34%]
........................................................................ [ 38%]
...........F.F.F.F...FFFF.F..FF.FF....FF....FF.F........F.FFF.FFFF..F.F. [ 42%]
..F....F..FFFF.F..F........F....FFFF.F.F.F..F.F.FF....F.FFFFFFF.F..F.F.. [ 46%]
FFFFF.F.F..FFFF...F..FF.FFF...FF.FFFFFFFFF..F..F..F.FF..F.F..F.....F...F [ 50%]
FF.F....F.F.F..FFF.F..F..                                                [ 52%]
259045253/test/blackbox/random_testing/test_src_lexer.py ............... [ 53%]
........................................................................ [ 57%]
........................................................................ [ 61%]
........................................................................ [ 65%]
........................................................................ [ 69%]
........................................................................ [ 73%]
........................................................................ [ 77%]
........................................................................ [ 81%]
.............................................................F.......... [ 85%]
......................F...........................................F..... [ 89%]
........................................................................ [ 93%]
..................................................................F..... [ 97%]
............................................                             [100%]

=================================== FAILURES ===================================
________________________________ test_case_670 _________________________________

expressions = [ContinueStatement()], env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
            for expression in expressions:
>               result = _eval(expression, env)
                         ^^^^^^^^^^^^^^^^^^^^^^

src/evaluator.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = ContinueStatement(), env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
>           raise _ContinueSignal()
E           src.evaluator._ContinueSignal

src/evaluator.py:389: _ContinueSignal

During handling of the above exception, another exception occurred:

    def test_case_670():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        continue_statement_0 = module_1.ContinueStatement()
        list_0 = [continue_statement_0]
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5797: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = [ContinueStatement()], env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
            for expression in expressions:
                result = _eval(expression, env)
            return result
        except _ExitSignal as e:
            return e.code
        except _ReturnSignal as e:
            return e.value
        except _ContinueSignal:
>           raise RuntimeEvaluationError("continue used outside loop")
E           src.evaluator.RuntimeEvaluationError: continue used outside loop

src/evaluator.py:446: RuntimeEvaluationError
________________________________ test_case_672 _________________________________

    def test_case_672():
        none_type_0 = None
>       module_0.evaluate(none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5809: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_674 _________________________________

    def test_case_674():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        list_0 = []
        module_0.evaluate(list_0)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_676 _________________________________

    def test_case_676():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = False
        list_0 = []
        module_0.evaluate(list_0)
>       module_0.evaluate(bool_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = False, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_680 _________________________________

    def test_case_680():
        str_0 = "<X0rCe\x0b=C(:jS{"
        module_0.setup_runtime(str_0)
        none_type_0 = None
        bool_0 = False
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        var_0 = boolean_literal_0.__repr__()
        var_1 = var_0.__repr__()
        var_2 = var_1.__eq__(none_type_0)
        var_3 = var_2.__repr__()
        var_4 = var_3.__repr__()
        var_5 = var_4.__repr__()
        list_0 = [var_5]
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5876: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = '"\'NotImplemented\'"', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_681 _________________________________

    def test_case_681():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        bool_0 = False
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0, bool_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5885: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = False

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_682 _________________________________

    def test_case_682():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5895: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_683 _________________________________

    def test_case_683():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        list_0 = module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5902: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal()
env = [{'arg': ('Number of parameters passed is not equal to number of function parameters', True)}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_685 _________________________________

    def test_case_685():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = "JTE"
>       module_0.evaluate(str_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5916: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'J', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_688 _________________________________

    def test_case_688():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        none_type_0 = None
>       module_0.evaluate(none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5939: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_689 _________________________________

    def test_case_689():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        bool_0 = False
>       module_0.evaluate(bool_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5948: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = False, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_691 _________________________________

    def test_case_691():
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5962: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_692 _________________________________

    def test_case_692():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = False
        exit_signal_0 = module_0._ExitSignal(bool_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
>       module_0.evaluate(exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:5972: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(False), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_697 _________________________________

    def test_case_697():
        str_0 = '"Ow'
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        list_0 = module_0.setup_runtime(str_0)
        list_1 = []
        var_0 = module_0.evaluate(list_1)
        var_1 = var_0.__eq__(list_0)
        var_2 = var_0.__eq__(var_1)
>       module_0.evaluate(var_2)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = NotImplemented, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NotImplementedType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_698 _________________________________

    def test_case_698():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        list_1 = [var_0, var_0]
>       module_0.evaluate(list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6023: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = None, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type NoneType

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_703 _________________________________

    def test_case_703():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6063: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_704 _________________________________

    def test_case_704():
        bool_0 = False
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        var_1 = var_0.__repr__()
        var_2 = var_1.__repr__()
        var_3 = var_2.__repr__()
        var_4 = var_3.__eq__(bool_0)
        prefix_expression_0 = module_1.PrefixExpression(var_4, var_3)
        list_1 = [prefix_expression_0, var_1]
>       module_0.evaluate(list_1, var_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6076: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
src/evaluator.py:295: in _eval
    right = _eval(node.right, env) if node.right is not None else None
            ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = '"\'None\'"', env = 'None'

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_706 _________________________________

    def test_case_706():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        list_1 = []
        var_1 = module_0.evaluate(list_1)
        list_2 = [var_1, var_1, var_1, var_0]
>       module_0.evaluate(list_2)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6096: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = None, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type NoneType

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_715 _________________________________

    def test_case_715():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        module_0.evaluate(list_0, bool_0)
        list_1 = [boolean_literal_0, boolean_literal_0, var_0, var_0]
>       module_0.evaluate(list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = True, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type bool

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_717 _________________________________

    def test_case_717():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        list_0 = []
        list_1 = []
        var_0 = module_0.evaluate(list_1)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
>       module_0.evaluate(var_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = []

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_718 _________________________________

    def test_case_718():
        bool_0 = True
        exit_signal_0 = module_0._ExitSignal(bool_0)
        module_0._ReturnSignal(bool_0)
>       module_0.evaluate(bool_0, exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = _ExitSignal(True)

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_719 _________________________________

    def test_case_719():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = True
        exit_signal_0 = module_0._ExitSignal(bool_0)
        bool_1 = True
        return_signal_0 = module_0._ReturnSignal(bool_1)
>       module_0.evaluate(return_signal_0, exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ReturnSignal(True), env = _ExitSignal(True)

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ReturnSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_721 _________________________________

    def test_case_721():
        set_0 = set()
        module_0._ReturnSignal(set_0)
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        none_type_0 = None
        infix_expression_0 = module_1.InfixExpression(set_0, set_0, none_type_0)
        list_0 = [infix_expression_0, infix_expression_0, infix_expression_0]
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
src/evaluator.py:306: in _eval
    left = _eval(node.lhs, env)
           ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = set(), env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type set

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_722 _________________________________

    def test_case_722():
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        list_0 = module_0.setup_runtime(str_0)
        none_type_0 = None
        integer_literal_0 = module_1.IntegerLiteral(none_type_0)
        var_0 = integer_literal_0.__repr__()
        var_1 = var_0.__repr__()
>       module_0.evaluate(list_0, var_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': ('Number of parameters passed is not equal to number of function parameters', True)}
env = "'IntegerLiteral(value=None)'"

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_723 _________________________________

    def test_case_723():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_724 _________________________________

    def test_case_724():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0, var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = True

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_727 _________________________________

    def test_case_727():
        str_0 = "<X0rCe\x0b=C(:jS{"
        module_0.setup_runtime(str_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
        expression_0 = module_1.Expression()
        list_0 = [expression_0]
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6284: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = <src.parser.Expression object at 0x10a5ee780>, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type Expression

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_729 _________________________________

    def test_case_729():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        set_0 = set()
        return_signal_0 = module_0._ReturnSignal(set_0)
>       module_0.evaluate(return_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ReturnSignal(set()), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ReturnSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_733 _________________________________

    def test_case_733():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        module_0.evaluate(list_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        none_type_0 = None
>       module_0.evaluate(none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_738 _________________________________

    def test_case_738():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        list_0 = []
        module_0.evaluate(list_0)
        str_1 = '"Ow'
        return_signal_0 = module_0._ReturnSignal(str_1)
>       module_0.evaluate(return_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ReturnSignal('"Ow'), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ReturnSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_741 _________________________________

    def test_case_741():
        str_0 = "<X0rCe\x0b=C(:jS{"
        module_0.setup_runtime(str_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0, bool_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6409: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_742 _________________________________

    def test_case_742():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_0)
        bool_1 = True
        boolean_literal_1 = module_1.BooleanLiteral(bool_1)
        list_1 = [boolean_literal_1, boolean_literal_1]
        var_0 = module_0.evaluate(list_1)
        module_0._ReturnSignal(boolean_literal_1)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_743 _________________________________

    def test_case_743():
        bool_0 = False
        exit_signal_0 = module_0._ExitSignal(bool_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        module_0.evaluate(list_0)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
>       module_0.evaluate(exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(False), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_744 _________________________________

    def test_case_744():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        set_0 = set()
        return_signal_0 = module_0._ReturnSignal(set_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_0)
>       module_0.evaluate(return_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ReturnSignal(set()), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ReturnSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_746 _________________________________

    def test_case_746():
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_0 = '"Ow'
        list_0 = module_0.setup_runtime(str_0)
        str_1 = "Number of parameters passed is not equal to number of function parameters"
>       module_0.evaluate(str_1, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'N', env = [{'arg': ('"Ow', True)}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_749 _________________________________

    def test_case_749():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = False
        exit_signal_0 = module_0._ExitSignal(bool_0)
        list_0 = []
        module_0.evaluate(list_0)
>       module_0.evaluate(exit_signal_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(False), env = []

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_758 _________________________________

    def test_case_758():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = False
        exit_signal_0 = module_0._ExitSignal(bool_0)
        bool_1 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_1)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_1)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        list_1 = []
        var_0 = module_0.evaluate(list_1)
>       module_0.evaluate(exit_signal_0, var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6585: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(False), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_763 _________________________________

    def test_case_763():
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        bool_1 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_1)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_1)
        str_0 = "2~ye{sL"
        list_1 = module_0.setup_runtime(str_0)
>       module_0.evaluate(list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6642: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': ('2~ye{sL', True)}, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_764 _________________________________

    def test_case_764():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        str_0 = "."
        module_0.setup_runtime(str_0)
        bool_1 = True
        boolean_literal_1 = module_1.BooleanLiteral(bool_1)
        list_1 = [boolean_literal_1, boolean_literal_1]
        var_1 = module_0.evaluate(list_1)
>       module_0.evaluate(var_0, var_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = True

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_765 _________________________________

    def test_case_765():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        module_0._ReturnSignal(boolean_literal_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_1 = []
        var_0 = module_0.evaluate(list_1)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_766 _________________________________

    def test_case_766():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0, bool_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_768 _________________________________

    def test_case_768():
        str_0 = "JTE"
        list_0 = module_0.setup_runtime(str_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
>       module_0.evaluate(list_0, bool_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': ('JTE', True)}, env = True

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_770 _________________________________

    def test_case_770():
        str_0 = '"Ow'
        module_0._ReturnSignal(str_0)
        str_1 = "JTE"
        list_0 = module_0.setup_runtime(str_1)
        bool_0 = False
        exit_signal_0 = module_0._ExitSignal(bool_0)
>       module_0.evaluate(list_0, exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6715: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': ('JTE', True)}, env = _ExitSignal(False)

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_772 _________________________________

    def test_case_772():
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        str_0 = '"Ow'
        module_0._ReturnSignal(str_0)
        str_1 = '"Ow'
        list_1 = module_0.setup_runtime(str_1)
>       module_0.evaluate(var_0, list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6737: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{'arg': ('"Ow', True)}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_775 _________________________________

    def test_case_775():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0, bool_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = True

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_777 _________________________________

    def test_case_777():
        set_0 = set()
        return_signal_0 = module_0._ReturnSignal(set_0)
>       module_0.evaluate(return_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ReturnSignal(set()), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ReturnSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_779 _________________________________

    def test_case_779():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_1 = "JTE"
        bool_1 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_1)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
>       module_0.evaluate(bool_0, str_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = 'JTE'

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_780 _________________________________

    def test_case_780():
        str_0 = "JTE"
        str_1 = "2~ye{sL"
        list_0 = module_0.setup_runtime(str_1)
>       module_0.evaluate(str_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6803: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'J', env = [{'arg': ('2~ye{sL', True)}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_785 _________________________________

    def test_case_785():
        continue_signal_0 = module_0._ContinueSignal()
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
>       module_0.evaluate(continue_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6849: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ContinueSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ContinueSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_787 _________________________________

    def test_case_787():
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_1 = True
>       module_0.evaluate(bool_1, bool_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6870: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = True

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_788 _________________________________

    def test_case_788():
        str_0 = "JTE"
        list_0 = module_0.setup_runtime(str_0)
        list_1 = []
        var_0 = module_0.evaluate(list_1)
>       module_0.evaluate(var_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6878: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{'arg': ('JTE', True)}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_789 _________________________________

    def test_case_789():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        var_0 = module_0.evaluate(list_0, bool_0)
        str_0 = "."
        list_1 = module_0.setup_runtime(str_0)
>       module_0.evaluate(var_0, list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6889: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{'arg': ('.', True)}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_790 _________________________________

    def test_case_790():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        list_0 = module_0.setup_runtime(str_0)
>       module_0.evaluate(str_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6895: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'N'
env = [{'arg': ('Number of parameters passed is not equal to number of function parameters', True)}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_791 _________________________________

    def test_case_791():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_792 _________________________________

    def test_case_792():
        str_0 = '>&I;sP\th/K\r$$k"9q"K'
        identifier_0 = module_1.Identifier(str_0)
        identifier_1 = module_1.Identifier(str_0)
        list_0 = [identifier_0, identifier_0, identifier_0, identifier_1]
>       module_0.evaluate(list_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6913: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
src/evaluator.py:133: in _eval
    val, _is_const = _get_var(env, node.name)
                     ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

env = [Identifier(name='>&I;sP\th/K\r$$k"9q"K'), Identifier(name='>&I;sP\th/K\r$$k"9q"K'), Identifier(name='>&I;sP\th/K\r$$k"9q"K'), Identifier(name='>&I;sP\th/K\r$$k"9q"K')]
name = '>&I;sP\th/K\r$$k"9q"K'

    def _get_var(env: "Env | Context", name: str) -> tuple[Any, bool]:
        stack = _env_stack(env)
        for context in stack[::-1]:
>           if name in context:
               ^^^^^^^^^^^^^^^
E           TypeError: argument of type 'Identifier' is not iterable

src/evaluator.py:70: TypeError
________________________________ test_case_793 _________________________________

    def test_case_793():
        int_0 = -760
        integer_literal_0 = module_1.IntegerLiteral(int_0)
        var_0 = integer_literal_0.__repr__()
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        list_0 = module_0.setup_runtime(str_0)
>       module_0.evaluate(var_0, list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6924: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'I'
env = [{'arg': ('Number of parameters passed is not equal to number of function parameters', True)}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_795 _________________________________

    def test_case_795():
        set_0 = set()
        return_signal_0 = module_0._ReturnSignal(set_0)
        runtime_evaluation_error_0 = module_0.RuntimeEvaluationError()
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        exit_signal_0 = module_0._ExitSignal(runtime_evaluation_error_0)
        list_0 = [exit_signal_0, return_signal_0]
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = _ExitSignal(RuntimeEvaluationError()), env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type _ExitSignal

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_798 _________________________________

    def test_case_798():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        var_0 = module_0.evaluate(list_0, bool_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
        return_signal_0 = module_0._ReturnSignal(break_signal_0)
>       module_0.evaluate(var_0, return_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:6980: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = _ReturnSignal(_BreakSignal())

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_800 _________________________________

    def test_case_800():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        set_0 = set()
        return_signal_0 = module_0._ReturnSignal(set_0)
        str_1 = "JTE"
>       module_0.evaluate(return_signal_0, str_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7003: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ReturnSignal(set()), env = 'JTE'

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ReturnSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_803 _________________________________

    def test_case_803():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        none_type_0 = None
>       module_0.evaluate(none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7034: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_804 _________________________________

    def test_case_804():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        str_1 = "Number of parameters passed is not equal to number of function parameters"
>       module_0.evaluate(str_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7041: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'N', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_805 _________________________________

    def test_case_805():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7049: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_806 _________________________________

    def test_case_806():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7057: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_807 _________________________________

    def test_case_807():
        bool_0 = True
        continue_signal_0 = module_0._ContinueSignal()
        module_0._ReturnSignal(continue_signal_0)
        none_type_0 = None
>       module_0.evaluate(bool_0, none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7065: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_809 _________________________________

    def test_case_809():
        set_0 = set()
        module_0._ReturnSignal(set_0)
        none_type_0 = None
        module_0.setup_runtime(none_type_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        list_1 = []
        var_1 = module_0.evaluate(list_1)
>       module_0.evaluate(var_1, var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7086: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_811 _________________________________

    def test_case_811():
        str_0 = "<X0rCe\x0b=C(:jS{"
        module_0.setup_runtime(str_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
>       module_0.evaluate(str_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = '<', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_814 _________________________________

    def test_case_814():
        base_exception_0 = module_2.BaseException()
>       module_0.evaluate(base_exception_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = BaseException(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'BaseException' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_815 _________________________________

    def test_case_815():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        runtime_evaluation_error_0 = module_0.RuntimeEvaluationError()
>       module_0.evaluate(runtime_evaluation_error_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = RuntimeEvaluationError(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'RuntimeEvaluationError' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_816 _________________________________

    def test_case_816():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        continue_signal_0 = module_0._ContinueSignal()
        module_0.evaluate(list_0, bool_0)
        str_0 = "<X0rCe\x0b=C(:jS{"
        module_0.setup_runtime(str_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
>       module_0.evaluate(continue_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ContinueSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ContinueSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_817 _________________________________

    def test_case_817():
        str_0 = '"Ow'
        module_0._ReturnSignal(str_0)
        str_1 = "JTE"
        list_0 = module_0.setup_runtime(str_1)
        list_1 = []
        module_0.evaluate(list_1)
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': ('JTE', True)}, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_821 _________________________________

    def test_case_821():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_0)
        none_type_0 = None
>       module_0.evaluate(none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_824 _________________________________

    def test_case_824():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_825 _________________________________

    def test_case_825():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        continue_signal_0 = module_0._ContinueSignal()
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_0)
>       module_0.evaluate(continue_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ContinueSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ContinueSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_827 _________________________________

    def test_case_827():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        list_0 = []
        module_0.evaluate(list_0)
        none_type_0 = None
        exit_signal_0 = module_0._ExitSignal(none_type_0)
>       module_0.evaluate(exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(None), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_828 _________________________________

    def test_case_828():
        list_0 = []
        module_0.evaluate(list_0)
        str_0 = '"Ow'
        module_0._ReturnSignal(str_0)
        str_1 = "Number of parameters passed is not equal to number of function parameters"
        list_1 = module_0.setup_runtime(str_1)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0, list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal()
env = [{'arg': ('Number of parameters passed is not equal to number of function parameters', True)}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_829 _________________________________

    def test_case_829():
        str_0 = '"Ow'
        module_0._ReturnSignal(str_0)
        str_1 = "Number of parameters passed is not equal to number of function parameters"
        list_0 = module_0.setup_runtime(str_1)
        continue_signal_0 = module_0._ContinueSignal(*list_0)
>       module_0.evaluate(continue_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ContinueSignal({'arg': ('Number of parameters passed is not equal to number of function parameters', True)})
env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ContinueSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_833 _________________________________

    def test_case_833():
        dict_0 = {}
        break_signal_0 = module_0._BreakSignal(**dict_0)
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        break_signal_1 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_1)
>       module_0.evaluate(break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_834 _________________________________

    def test_case_834():
        break_signal_0 = module_0._BreakSignal()
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_0 = "Ft;(9VZZ),|=+U+,X"
        module_0.setup_runtime(str_0)
        bool_1 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_1)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
>       module_0.evaluate(break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_836 _________________________________

    def test_case_836():
        set_0 = set()
        module_0._ReturnSignal(set_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        str_1 = "<X0rCe\x0b=C(:jS{"
>       module_0.evaluate(str_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = '<', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_837 _________________________________

    def test_case_837():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        str_2 = "<X0rCe\x0b=C(:jS{"
>       module_0.evaluate(str_2)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = '<', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_838 _________________________________

    def test_case_838():
        set_0 = set()
        module_0._ReturnSignal(set_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_1 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_1, bool_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_839 _________________________________

    def test_case_839():
        bytes_0 = b"\x98\x12\xb7\x85RQ\xea\x80\xb6\xf2\xa8[W\xd0"
        module_0._ReturnSignal(bytes_0)
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_840 _________________________________

    def test_case_840():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        module_0.evaluate(list_0, bool_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7377: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_841 _________________________________

    def test_case_841():
        none_type_0 = None
        identifier_0 = module_1.Identifier(none_type_0)
>       module_0.evaluate(identifier_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7383: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = Identifier(name=None), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'Identifier' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_842 _________________________________

    def test_case_842():
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        list_0 = []
        list_1 = [list_0, list_0]
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_2 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_2)
        module_0._ReturnSignal(boolean_literal_0)
>       module_0.evaluate(list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = [], env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type list

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_843 _________________________________

    def test_case_843():
        str_0 = "JTE"
        list_0 = module_0.setup_runtime(str_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': ('JTE', True)}, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_844 _________________________________

    def test_case_844():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
>       module_0.evaluate(str_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'J', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_847 _________________________________

    def test_case_847():
        bool_0 = True
        exit_signal_0 = module_0._ExitSignal(bool_0)
>       module_0.evaluate(exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7428: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(True), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_850 _________________________________

    def test_case_850():
        break_signal_0 = module_0._BreakSignal()
        str_0 = "<X0rCe\x0b=C(:jS{"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0, break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7461: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = _BreakSignal()

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_853 _________________________________

    def test_case_853():
        bool_0 = True
        module_0._ReturnSignal(bool_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_1 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_1)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7487: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_855 _________________________________

    def test_case_855():
        str_0 = "9~>,V\tk_"
        module_0.setup_runtime(str_0)
        none_type_0 = None
        exit_signal_0 = module_0._ExitSignal(none_type_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        module_0._ReturnSignal(boolean_literal_0)
>       module_0.evaluate(exit_signal_0, boolean_literal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(None), env = BooleanLiteral(literal=True)

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_856 _________________________________

    def test_case_856():
        set_0 = set()
        list_0 = module_0.setup_runtime(set_0)
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        list_1 = module_0.setup_runtime(str_0)
>       module_0.evaluate(list_0, list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7521: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = {'arg': (set(), True)}
env = [{'arg': ('Number of parameters passed is not equal to number of function parameters', True)}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type dict

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_859 _________________________________

    def test_case_859():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        module_0._ReturnSignal(boolean_literal_0)
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        str_1 = "$rq)>ng,]BiiA ;7or{"
        null_literal_0 = module_1.NullLiteral(str_1)
        list_1 = [null_literal_0, null_literal_0, null_literal_0]
        module_0.evaluate(list_1)
        int_0 = 14
        exit_signal_0 = module_0._ExitSignal(int_0)
>       module_0.evaluate(exit_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7557: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ExitSignal(14), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ExitSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_861 _________________________________

    def test_case_861():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        dict_0 = {}
        break_signal_0 = module_0._BreakSignal(**dict_0)
        module_0._ReturnSignal(break_signal_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0)
        list_1 = []
        var_0 = module_0.evaluate(list_1)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_864 _________________________________

    def test_case_864():
        set_0 = set()
        module_0._ReturnSignal(set_0)
        bytes_0 = b"\xb1'\xc9K\x88\x89"
        exit_signal_0 = module_0._ExitSignal(bytes_0)
        list_0 = [bytes_0, exit_signal_0, bytes_0, exit_signal_0]
>       module_0.evaluate(list_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7610: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = b"\xb1'\xc9K\x88\x89", env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type bytes

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_870 _________________________________

    def test_case_870():
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
        bool_0 = False
        module_0.setup_runtime(bool_0)
        bytes_0 = b"\xb1'\xc9K\x88\x89"
>       module_0.evaluate(bytes_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7661: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 177, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type int

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_874 _________________________________

    def test_case_874():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        module_0.evaluate(list_0)
        set_0 = set()
        module_0._ReturnSignal(set_0)
        none_type_0 = None
>       module_0.evaluate(none_type_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7697: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_875 _________________________________

    def test_case_875():
        str_0 = "Number of parameters passed is not equal to number of function parameters"
        module_0.setup_runtime(str_0)
        str_1 = '"Ow'
        module_0._ReturnSignal(str_1)
        continue_signal_0 = module_0._ContinueSignal()
        list_0 = []
        module_0.evaluate(list_0)
>       module_0.evaluate(continue_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7708: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _ContinueSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_ContinueSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_876 _________________________________

    def test_case_876():
        str_0 = "9~>,V\tk_"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7715: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_878 _________________________________

    def test_case_878():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        var_1 = module_0.evaluate(list_0, bool_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
        module_0._ReturnSignal(break_signal_0)
>       module_0.evaluate(var_0, var_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7735: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = True, env = True

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'bool' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_883 _________________________________

    def test_case_883():
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        runtime_evaluation_error_0 = module_0.RuntimeEvaluationError()
        var_1 = var_0.__eq__(runtime_evaluation_error_0)
        module_0._ReturnSignal(var_1)
        str_0 = "9~>,V\tk_"
        module_0.setup_runtime(str_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7778: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_885 _________________________________

    def test_case_885():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        var_1 = module_0.evaluate(list_0)
>       module_0.evaluate(var_1, var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_887 _________________________________

    def test_case_887():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = True
        module_0._ReturnSignal(bool_0)
>       module_0.evaluate(str_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7813: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = 'J', env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type str

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_890 _________________________________

    def test_case_890():
        list_0 = []
        var_0 = module_0.evaluate(list_0)
        str_0 = "q7LO)MceS\\bti*"
        module_0.setup_runtime(str_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_1 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_1, bool_0)
        dict_0 = {}
        continue_signal_0 = module_0._ContinueSignal(**dict_0)
        module_0._ReturnSignal(continue_signal_0)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7842: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_891 _________________________________

    def test_case_891():
        continue_signal_0 = module_0._ContinueSignal()
        module_0._ReturnSignal(continue_signal_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        var_1 = module_0.evaluate(list_0, bool_0)
        str_0 = '"Ow'
        module_0.setup_runtime(str_0)
        list_1 = [var_1, boolean_literal_0, var_1, var_0]
>       module_0.evaluate(list_1)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7856: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/evaluator.py:439: in evaluate
    result = _eval(expression, env)
             ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

node = True, env = [{}]

    def _eval(node: Expression, env: "Env | Context") -> Any:
        if isinstance(node, IntegerLiteral):
            return int(node.value)
    
        if isinstance(node, FloatLiteral):
            return float(node.value)
    
        if isinstance(node, BooleanLiteral):
            return bool(node.literal)
    
        if isinstance(node, NullLiteral):
            return None
    
        if isinstance(node, CharLiteral):
            return str(node.literal)
    
        if isinstance(node, StringLiteral):
            return str(node.literal)
    
        if isinstance(node, Identifier):
            val, _is_const = _get_var(env, node.name)
            return val
    
        if isinstance(node, CallExpression):
            name = node.identifier_name
            args = []
            for arg in node.parameters:
                args.append(_eval(arg, env))
            if name == "sqrt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("sqrt expects 1 arguments")
                return float(math.sqrt(args[0]))
            elif name == "pow":
                if len(args) != 2:
                    raise RuntimeEvaluationError("pow expects 2 arguments")
                return float(math.pow(args[0], args[1]))
            elif name == "ceil":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ceil expects 1 arguments")
                return int(math.ceil(args[0]))
            elif name == "floor":
                if len(args) != 1:
                    raise RuntimeEvaluationError("floor expects 1 arguments")
                return int(math.floor(args[0]))
            elif name == "abs":
                if len(args) != 1:
                    raise RuntimeEvaluationError("abs expects 1 arguments")
                return abs(args[0])
            elif name == "println":
                print(*args)
                return None
            elif name == "print":
                print(*args, end="")
                return None
            elif name == "input":  # pragma: no cover
                if len(args) > 1:
                    raise RuntimeEvaluationError("input expects 0 or 1 arguments")
                elif len(args) == 0:
                    return input()
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("input only expects a string input")
                return input(str(args[0]))
            elif name == "isInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_int expects 1 argument")
                return args[0].isnumeric()
            elif name == "toInt":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_int expects 1 argument")
                try:
                    return int(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to int")
            elif name == "isFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("is_float expects 1 argument")
                try:
                    float(args[0])
                    return True
                except (ValueError, TypeError):
                    return False
            elif name == "toFloat":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_float expects 1 argument")
                try:
                    return float(args[0])
                except (ValueError, TypeError):
                    raise RuntimeEvaluationError("Cannot convert value to float")
            elif name == "toStr":
                if len(args) != 1:
                    raise RuntimeEvaluationError("to_str expects 1 argument")
                return str(args[0])
            elif name == "concat":
                if len(args) != 2:
                    raise RuntimeEvaluationError("concat expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[0] + args[1]
            elif name == "trim":
                if len(args) != 1:
                    raise RuntimeEvaluationError("trim expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return args[0].strip()
            elif name == "hasPrefix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasPrefix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].startswith(args[0])
            elif name == "hasSuffix":
                if len(args) != 2:
                    raise RuntimeEvaluationError("hasSuffix expects 2 arguments")
                for arg in args:
                    if not isinstance(arg, str):
                        raise RuntimeEvaluationError("Input is not a string")
                return args[1].endswith(args[0])
            elif name == "length":
                if len(args) != 1:
                    raise RuntimeEvaluationError("length expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return len(args[0])
            elif name == "ifExists":
                if len(args) != 1:
                    raise RuntimeEvaluationError("ifExists expects 1 argument")
                if not isinstance(args[0], str):
                    raise RuntimeEvaluationError("Input is not a string")
                return _is_declared(env, args[0])
            elif name == "exit":
                if len(args) != 1:
                    raise RuntimeEvaluationError("exit expects 1 argument")
                if isinstance(args[0], bool) or not isinstance(args[0], int):
                    raise RuntimeEvaluationError("eixt argument must be int")
                raise _ExitSignal(args[0])
            elif name == "type":
                if len(args) != 1:
                    raise RuntimeEvaluationError("type expects 1 argument")
                v = args[0]
    
                if v is None:
                    return "null"
                if isinstance(v, bool):
                    return "boolean"
                if isinstance(v, int):
                    return "integer"
                if isinstance(v, float):
                    return "float"
                if isinstance(v, str):
                    return "string"
                if isinstance(v, FunctionStatement):
                    return "function"
    
                return "unknown"
            else:
                stack = _env_stack(env)
                stack.append({})
                function = _get_var(stack, node.identifier_name)[0]
                if not isinstance(function, FunctionStatement):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Looked for function but found another identifier instead"
                    )
    
                if len(node.parameters) != len(function.variables):
                    stack.pop()
                    raise RuntimeEvaluationError(
                        "Number of parameters passed is not equal to number of function parameters"
                    )
                for identifier, expression in zip(function.variables, node.parameters):
                    _declare_var(stack, identifier.name, _eval(expression, env), False)
                try:
                    result = _eval(function.block, stack)
                    stack.pop()
                    return result
                except _ReturnSignal as e:
                    stack.pop()
                    return e.value
    
        if isinstance(node, PrefixExpression):
            right = _eval(node.right, env) if node.right is not None else None
            op = node.token
            if op == Token.MINUS:
                return -right
            if op == Token.PLUS:
                return +right
            if op == Token.NOT:
                return not bool(right)
            raise RuntimeEvaluationError(f"Unsupported prefix operator '{op}'")
    
        if isinstance(node, InfixExpression):
            left = _eval(node.lhs, env)
            right = _eval(node.rhs, env)
            t = node.operation
    
            # arithmetic
            if t == Token.PLUS:
                return left + right
            if t == Token.MINUS:
                return left - right
            if t == Token.ASTERISK:
                return left * right
            if t == Token.SLASH:
                if right == 0:
                    raise RuntimeEvaluationError("Division by zero")
                return left / right
    
            # bitwise
            if t == Token.BITWISE_AND:
                _check_integer_operands(left, right)
                return left & right
            if t == Token.BITWISE_OR:
                _check_integer_operands(left, right)
                return left | right
            if t == Token.BITWISE_XOR:
                _check_integer_operands(left, right)
                return left ^ right
    
            # comparisons
            if t == Token.EQUAL:
                return left == right
            if t == Token.NOTEQUAL:
                return left != right
            if t == Token.LESS:
                return left < right
            if t == Token.LESSEQUAL:
                return left <= right
            if t == Token.GREATER:
                return left > right
            if t == Token.GREATEREQUAL:
                return left >= right
    
            # logical
            if t == Token.AND:
                return bool(left) and bool(right)
            if t == Token.OR:
                return bool(left) or bool(right)
    
            raise RuntimeEvaluationError(f"Unsupported infix operator '{t}'")
    
        if isinstance(node, LetStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=False)
    
        if isinstance(node, ConstStatement):
            value = _eval(node.expression, env)
            return _declare_var(env, node.identifier.name, value, is_const=True)
    
        if isinstance(node, AssignExpression):
            if not isinstance(node.lhs, Identifier):
                raise RuntimeEvaluationError(
                    "Left-hand side of assignment must be a variable"
                )
            value = _eval(node.rhs, env)
            return _assign_var(env, node.lhs.name, value)
    
        if isinstance(node, ExpressionStatement):
            if node.expression is None:
                return None
            return _eval(node.expression, env)
    
        if isinstance(node, BlockStatement):
            result = None
            for stmt in node.statements:
                result = _eval(stmt, env)
            return result
    
        if isinstance(node, IfExpression):
            cond = _eval(node.condition, env)
            if cond:
                return _eval(node.consequence, env) if node.consequence else None
            return _eval(node.alternative, env) if node.alternative else None
    
        if isinstance(node, ContinueStatement):
            raise _ContinueSignal()
        if isinstance(node, BreakStatement):
            raise _BreakSignal()
    
        if isinstance(node, ForStatement):
            _eval(node.initialization, env)
    
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    _eval(node.increment, env)
                    continue
                except _BreakSignal:
                    break
                _eval(node.increment, env)
            return result
    
        if isinstance(node, WhileStatement):
            result = None
            while bool(_eval(node.condition, env)):
                try:
                    result = _eval(node.block, env)
                except _ContinueSignal:
                    continue
                except _BreakSignal:
                    break
            return result
    
        if isinstance(node, FunctionStatement):
            _declare_var(env, node.identifier.name, node, True)
            return None
    
        if isinstance(node, ReturnStatement):
            evaluation = _eval(node.expression, env) if node.expression != None else ""
            raise _ReturnSignal(evaluation)
    
>       raise RuntimeEvaluationError(
            f"Evaluation not implemented for node type {type(node).__name__}"
        )
E       src.evaluator.RuntimeEvaluationError: Evaluation not implemented for node type bool

src/evaluator.py:427: RuntimeEvaluationError
________________________________ test_case_892 _________________________________

    def test_case_892():
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        module_0.evaluate(list_0, bool_0)
        list_1 = []
        var_0 = module_0.evaluate(list_1)
>       module_0.evaluate(var_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7868: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = None, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'NoneType' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_894 _________________________________

    def test_case_894():
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        module_0._ReturnSignal(boolean_literal_0)
        list_1 = []
        module_0.evaluate(list_1, var_0)
        str_0 = "JTE"
        module_0.setup_runtime(str_0)
        break_signal_0 = module_0._BreakSignal()
>       module_0.evaluate(break_signal_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7893: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = _BreakSignal(), env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: '_BreakSignal' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_897 _________________________________

    def test_case_897():
        continue_signal_0 = module_0._ContinueSignal()
        module_0._ReturnSignal(continue_signal_0)
        bool_0 = True
        boolean_literal_0 = module_1.BooleanLiteral(bool_0)
        list_0 = [boolean_literal_0, boolean_literal_0]
        var_0 = module_0.evaluate(list_0)
        list_1 = []
        module_0.evaluate(list_1, var_0)
        str_0 = "Ft;(9VZZ),|=+U+,X"
        module_0.setup_runtime(str_0)
        float_0 = -4124.58542
>       module_0.evaluate(float_0)

259045253/test/blackbox/random_testing/test_src_evaluator.py:7927: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

expressions = -4124.58542, env = [{}]

    def evaluate(expressions: list[Expression], env: Env | None = None) -> Any:
        if env is None:
            env = [{}]
    
        try:
            result = None
>           for expression in expressions:
E           TypeError: 'float' object is not iterable

src/evaluator.py:438: TypeError
________________________________ test_case_580 _________________________________

    def test_case_580():
        bool_0 = False
>       module_0.Lexer(bool_0)

259045253/test/blackbox/random_testing/test_src_lexer.py:7310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/lexer.py:13: in __init__
    self.read_char()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Lexer()

    def read_char(self) -> None:
>       if self.read_position >= len(self.input):
                                 ^^^^^^^^^^^^^^^
E       TypeError: object of type 'bool' has no len()

src/lexer.py:16: TypeError
________________________________ test_case_613 _________________________________

    def test_case_613():
        none_type_0 = None
>       module_0.Lexer(none_type_0)

259045253/test/blackbox/random_testing/test_src_lexer.py:7711: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/lexer.py:13: in __init__
    self.read_char()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Lexer()

    def read_char(self) -> None:
>       if self.read_position >= len(self.input):
                                 ^^^^^^^^^^^^^^^
E       TypeError: object of type 'NoneType' has no len()

src/lexer.py:16: TypeError
________________________________ test_case_657 _________________________________

    def test_case_657():
        int_0 = -2579
>       module_0.Lexer(int_0)

259045253/test/blackbox/random_testing/test_src_lexer.py:8275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/lexer.py:13: in __init__
    self.read_char()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Lexer()

    def read_char(self) -> None:
>       if self.read_position >= len(self.input):
                                 ^^^^^^^^^^^^^^^
E       TypeError: object of type 'int' has no len()

src/lexer.py:16: TypeError
________________________________ test_case_801 _________________________________

    def test_case_801():
        int_0 = 20
>       module_0.Lexer(int_0)

259045253/test/blackbox/random_testing/test_src_lexer.py:10166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/lexer.py:13: in __init__
    self.read_char()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Lexer()

    def read_char(self) -> None:
>       if self.read_position >= len(self.input):
                                 ^^^^^^^^^^^^^^^
E       TypeError: object of type 'int' has no len()

src/lexer.py:16: TypeError
=========================== short test summary info ============================
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_670
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_672
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_674
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_676
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_680
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_681
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_682
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_683
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_685
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_688
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_689
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_691
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_692
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_697
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_698
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_703
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_704
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_706
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_715
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_717
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_718
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_719
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_721
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_722
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_723
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_724
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_727
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_729
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_733
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_738
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_741
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_742
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_743
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_744
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_746
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_749
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_758
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_763
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_764
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_765
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_766
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_768
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_770
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_772
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_775
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_777
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_779
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_780
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_785
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_787
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_788
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_789
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_790
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_791
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_792
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_793
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_795
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_798
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_800
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_803
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_804
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_805
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_806
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_807
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_809
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_811
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_814
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_815
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_816
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_817
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_821
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_824
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_825
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_827
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_828
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_829
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_833
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_834
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_836
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_837
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_838
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_839
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_840
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_841
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_842
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_843
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_844
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_847
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_850
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_853
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_855
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_856
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_859
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_861
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_864
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_870
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_874
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_875
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_876
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_878
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_883
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_885
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_887
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_890
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_891
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_892
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_894
FAILED 259045253/test/blackbox/random_testing/test_src_evaluator.py::test_case_897
FAILED 259045253/test/blackbox/random_testing/test_src_lexer.py::test_case_580
FAILED 259045253/test/blackbox/random_testing/test_src_lexer.py::test_case_613
FAILED 259045253/test/blackbox/random_testing/test_src_lexer.py::test_case_657
FAILED 259045253/test/blackbox/random_testing/test_src_lexer.py::test_case_801
====================== 112 failed, 1673 passed in 12.10s =======================
